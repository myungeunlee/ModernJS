12 함수
================
12.1 함수란
-----------
 프로그래밍 언어의 함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것
 ```javaScript
 function add(x,y){   //함수정의
  return x+y;
 }
 add(2,5)     //함수호출
 ```
 
 12.2 함수를 사용하는 이유
 -----------
 - 함수는 필요할 떄 여러번 호출 가능
 - 개발자가 실행 시점을 결정할 수 있음
 - => 코드의 재사용
> 1)  유지보수의 편의성 제공
> 2)  실수를 줄여 코드의 신뢰성 향상


12.3 함수리터럴
----------
- 자바스크립트의 함수는 객체 타입의 값
- 구성: function 키위드, 함수 이름, 매개변수 목록, 함수 몸체
- 함수는 객체이다: 일반객체는 호출할 수 없지만 함수는 호출 할 수 있음, 함수 객체는 고유한 프로퍼티를 가짐


12.4 함수 정의
---------
함수를 호출하기 전 매개변수, 실행문, 반환값을 지정하는 것

### 함수 정의 방식
### 1) 함수 선언문  
함수 이름 생략 불가능   
표현식이 아닌 문!
```javaScript
function add(x,y){   
  return x+y;
}
add(2,5)
```  
이름이 있는 함수 리터럴은 함수 선언문 또는 함수 리터럴 표현식으로 해석될 수 있음.  
즉, {} 는 코드 블럭일 수 도 있고 객체 리터럴일 수도 있음  
이러한 중의적인 표현 때문에 코드 문맥에 따라 해석됨  
```JavaScirpt
// 함수 선언문은 표현식이 아닌 문이므로 변수에 할당 할 수 없음.
// but) 가능. 기명 함수 리터럴로 인식함.
var add = function add(x,y){   
  return x+y;
}
```   
기명 함수 리터럴를 독단적으로 사용하면 함수 선언문으로 인식함.  

함수 선언문 or 함수 리터럴이던 함수가 생성되는 것은 동일하지만 생성하는 내부 동작에는 차이가 있음.
```javaScript
(function bar(){console.log('bar');});
bar() //referenceError 
```
그룹연산자() 안에 있는 함수 리터럴은 함수 선언문으로 해석되지 않고 함수 리터럴 표현식으로 해석됨  

자바스크립트 엔진은 함수 선언문을 해석해 함수 객체를 생성하고  
생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 거기에 함수 객체를 할당  
함수는 함수 이름으로 호출되는 것이 아니라 함수 객체를 가리키는 식별자로 호출함



### 2) 함수 표현식
자바스크립트의 함수는 일급 객체(=값처럼 자유롭게 사용할 수 있음)  
표현식인 문!
```javaScript
//함수 표현식
var add = function (x, y){
 return x+y;
}
console.log(add(2,3)); //5
```
함수 리터럴의 함수 이름 생략 가능 = 익명함수  
```javaScript
//함수 표현식
var add = function foo (x, y){
 return x+y;
}
console.log(add(2,3)); //5
console.log(foo(2,3)); //ReferenceError 발생: 함수 호출할 때 함수 이름이 아니라 함수 객체를 가리키는 식별자를 사용해야 함.
```

### 3)  함수 생성 시점과 함수 호이스팅
함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있음(런타임 이전에 함수 객체 생성)  
함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없음  
=> 함수 생성 시점이 다름  

> 호이스팅의 초기화
> 변수의 호이스팅: undefined로 초기화됨
> 함수 선언문의 호이스팅: 함수 객체로 초기화됨 => 함수 선언문 이전에 호출이 가능함 

```javaScript
// 함수 참조
console.dir(add); // ƒ add(x, y)
console.dir(sub); // undefined

// 함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 표현식
var sub = function (x, y) {
  return x - y;
};
```
함수 표현식은 변수 선언는 호이스팅 되어 undefined로 초기화 되지만,  
변수 할당문의 값은 할당문이 실행되는 시점에 평가되어 함수 객체가 됨 => 변수 호이스팅 발생  

### 4) Function 생성자 함수
```javaScript
var add = new Function('x', 'y', 'return x + y');
console.log(add(2, 5)); // 7
```
Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하여 만드는 함수  
일반적인 함수 생성 방식x  
클로저를 생성하지 않는 등 다른 함수 생성하는 방식과 동작이 다름  
```javaScript
var add2 = (function () {
  var a = 10;
  return new Function('x', 'y', 'return x + y + a;');
}());

console.log(add2(1, 2)); // ReferenceError: a is not defined
```

### 5) 화살표함수
function 키워드 대신 화살표를 사용해 간락한 방법으로 함수 선언하는 방법.  
항상 익명 함수  
prototype 프로퍼티가 없음  
arguments 객체 생성x  
this 바인딩 방식
```javaScript
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```


12.5 함수 호출
-------------
### 매개변수
- 인수를 순서대로 함수내부로 전달함
- 변수와 마찬가지로 undefined로 초기화됨
- 스코프는 함수 내부
- 함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크 x 
 > =>인수가 부족할 경우 매개변수는 undefinded 임  
 > =>인수가 많을 경우 argments 객체의 프로퍼티로 보관됨
```javaScript
function add(x, y) {
  return x + y;
}

console.log(add(2)); // NaN
```


### 참고
- 리터럴: 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기 방식. 값을 생성하기 위한 표기법
