12 함수
================
12.1 함수란
-----------
 프로그래밍 언어의 함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것
 ```javaScript
 function add(x,y){   //함수정의
  return x+y;
 }
 add(2,5)     //함수호출
 ```
 
 12.2 함수를 사용하는 이유
 -----------
 - 함수는 필요할 떄 여러번 호출 가능
 - 개발자가 실행 시점을 결정할 수 있음
 - => 코드의 재사용
> 1)  유지보수의 편의성 제공
> 2)  실수를 줄여 코드의 신뢰성 향상


12.3 함수리터럴
----------
- 자바스크립트의 함수는 객체 타입의 값
- 구성: function 키위드, 함수 이름, 매개변수 목록, 함수 몸체
- 함수는 객체이다: 일반객체는 호출할 수 없지만 함수는 호출 할 수 있음, 함수 객체는 고유한 프로퍼티를 가짐


12.4 함수 정의
---------
함수를 호출하기 전 매개변수, 실행문, 반환값을 지정하는 것

### 함수 정의 방식
### 1) 함수 선언문  
함수 이름 생략 불가능   
표현식이 아닌 문!
```javaScript
function add(x,y){   
  return x+y;
}
add(2,5)
```  
이름이 있는 함수 리터럴은 함수 선언문 또는 함수 리터럴 표현식으로 해석될 수 있음.  
즉, {} 는 코드 블럭일 수 도 있고 객체 리터럴일 수도 있음  
이러한 중의적인 표현 때문에 코드 문맥에 따라 해석됨  
```JavaScirpt
// 함수 선언문은 표현식이 아닌 문이므로 변수에 할당 할 수 없음.
// but) 가능. 기명 함수 리터럴로 인식함.
var add = function add(x,y){   
  return x+y;
}
```   
기명 함수 리터럴를 독단적으로 사용하면 함수 선언문으로 인식함.  

함수 선언문 or 함수 리터럴이던 함수가 생성되는 것은 동일하지만 생성하는 내부 동작에는 차이가 있음.
```javaScript
(function bar(){console.log('bar');});
bar() //referenceError 
```
그룹연산자() 안에 있는 함수 리터럴은 함수 선언문으로 해석되지 않고 함수 리터럴 표현식으로 해석됨  

자바스크립트 엔진은 함수 선언문을 해석해 함수 객체를 생성하고  
생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 거기에 함수 객체를 할당  
함수는 함수 이름으로 호출되는 것이 아니라 함수 객체를 가리키는 식별자로 호출함



### 2) 함수 표현식
자바스크립트의 함수는 일급 객체(=값처럼 자유롭게 사용할 수 있음)  
표현식인 문!
```javaScript
//함수 표현식
var add = function (x, y){
 return x+y;
}
console.log(add(2,3)); //5
```
함수 리터럴의 함수 이름 생략 가능 = 익명함수  
```javaScript
//함수 표현식
var add = function foo (x, y){
 return x+y;
}
console.log(add(2,3)); //5
console.log(foo(2,3)); //ReferenceError 발생: 함수 호출할 때 함수 이름이 아니라 함수 객체를 가리키는 식별자를 사용해야 함.
```

### 3)  함수 생성 시점과 함수 호이스팅
함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있음(런타임 이전에 함수 객체 생성)  
함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없음  
=> 함수 생성 시점이 다름  

> 호이스팅의 초기화
> 변수의 호이스팅: undefined로 초기화됨
> 함수 선언문의 호이스팅: 함수 객체로 초기화됨 => 함수 선언문 이전에 호출이 가능함 

```javaScript
// 함수 참조
console.dir(add); // ƒ add(x, y)
console.dir(sub); // undefined

// 함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 표현식
var sub = function (x, y) {
  return x - y;
};
```
함수 표현식은 변수 선언는 호이스팅 되어 undefined로 초기화 되지만,  
변수 할당문의 값은 할당문이 실행되는 시점에 평가되어 함수 객체가 됨 => 변수 호이스팅 발생  

### 4) Function 생성자 함수
```javaScript
var add = new Function('x', 'y', 'return x + y');
console.log(add(2, 5)); // 7
```
Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하여 만드는 함수  
일반적인 함수 생성 방식x  
클로저를 생성하지 않는 등 다른 함수 생성하는 방식과 동작이 다름  
```javaScript
var add2 = (function () {
  var a = 10;
  return new Function('x', 'y', 'return x + y + a;');
}());

console.log(add2(1, 2)); // ReferenceError: a is not defined
```

### 5) 화살표함수
function 키워드 대신 화살표를 사용해 간락한 방법으로 함수 선언하는 방법.  
항상 익명 함수  
prototype 프로퍼티가 없음  
arguments 객체 생성x  
this 바인딩 방식
```javaScript
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```


12.5 함수 호출
-------------
### 매개변수
- 인수를 순서대로 함수내부로 전달함
- 변수와 마찬가지로 undefined로 초기화됨
- 스코프는 함수 내부
- 함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크 x 
 > =>인수가 부족할 경우 매개변수는 undefined 임  
 > =>인수가 많을 경우 argments 객체의 프로퍼티로 보관됨
```javaScript
function add(x, y) {
  return x + y;
}
console.log(add(2)); // NaN
```
> 오류 방지
> - 타입스크립트와 같은 정적 타입을 선언할 수 있도록 컴파일 시점에 오류를 잡을 수 있음
> - arguments 객체를 통해 인수 객수를 확인
> - 매개변수 기본값으로 인수 체크
- 매개변수는 최대 3개를 넘지 않도록 권장, 적을수록 좋음


### 반환문
- 반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나감
- 반환문은 return 키워드 뒤에 오는 표현식을 평가해 반환
- return 뒤 표현식을 생략할 경우 undefined 반환
- 반환문은 함수 몸체 내부에서만 사용 가능

12.6 참조에 의한 전달과 외부 상태의 변경
----------
매개변수에 원시 타입 인수는 값 자체가 복사되어 매개변수에 전달됨 => 원본 훼손 안됨
매개변수에 객체 인수를 전달하게 되면 참조 값이 복사되어 매개변수에 전달됨. => 원본 훼손 됨.
> 해결방법: 객체를 불변 객체로 만들어 사용


12.7 다양한 함수의 형태
-----------
### 즉시실행 함수  
- 함수 정의와 동시에 호출 됨
- 단 한번만 호출됨
```javaScript
(function () {
  var a = 3;
  var b = 5;
  return a * b;
}());
```
- 그룹 연산자로 감싸야함 => 그렇지 않으면 SyntaxError 발생
```javaScript
function foo() {}(); // => function foo() {};(); 여기서 ()는 그룹연산자로 인식하여 그룹연산자의 피연산자가 없어 에러발생
```
- 그룹 연산자의 피연산자는 값으로 평가되므로 에러 발생 x
```javaScript
//일반적인 방법
(function () {
  // ...
}());

(function () {
  // ...
})();

!function () {
  // ...
}();

+function () {
  // ...
}();
```
- 값을 반환 할 수 있음
```javaScript
var res = (function () {
  var a = 3;
  var b = 5;
  return a * b;
}());
```
- 인수를 전달 할 수도 있음
```javaScript
res = (function (a, b) {
  return a * b;
}(3, 5));
```

### 재귀함수
함수이름은 함수 몸체 내부에서만 유효함. 따라서 함수 내부에서 함수 이름 or 함수를 가리키는 식별자를 사용해 자기 자신을 호출 할 수 있음.  
단, 함수 외부에서 함수를 호출할 때는 반드시 함수를 가리키는 식별자로 호출해야 함  
```javaScript
// 함수 표현식
var factorial = function foo(n) {
  // 탈출 조건: n이 1 이하일 때 재귀 호출을 멈춘다.
  if (n <= 1) return 1;
  // 함수를 가리키는 식별자로 자기 자신을 재귀 호출
  return n * factorial(n - 1);

  // 함수 이름으로 자기 자신을 재귀 호출할 수도 있다.
  // console.log(factorial === foo); // true
  // return n * foo(n - 1);
};

console.log(factorial(5)); // 5! = 5 * 4 * 3 * 2 * 1 = 120
```

### 중첩 함수
- 중첩 함수: 함수 내부에 정의된 함수(=내부 함수), 일반적으로 외부 함수를 돕는 헬퍼 함수의 역할  
- 외부 함수: 중첩 함수를 포함한 함수   
- es6부터 함수 정의는 문이 위치할 수 있는 문맥이라면 어디든지 가능


### 콜백 함수
함수를 합성하여 함수의 변하지 않는 공통 로직은 미리 정의해 두고, 변경되는 로직은 추상화해서 함수 외부에서 내부로 전달하는 방법  
- 콜백 함수: 매개변수를 통해 다른 함수의 내부로 전달되는 함수, 고차 함수에 의해 호출됨
- 고차 함수: 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수, 콜백 함수를 자신의 일부분으로 합성, 콜백 함수에 인수를 전달할 수 있음
```javaScript
// 외부에서 전달받은 f를 n만큼 반복 호출한다
function repeat(n, f) {
  for (var i = 0; i < n; i++) {
    f(i); // i를 전달하면서 f를 호출
  }
}

//단 한 번만 생성됨
var logAll = function (i) {
  console.log(i);
};

// 반복 호출할 함수를 인수로 전달한다.
// 고차 함수에 함수 참조를 전달함.
repeat(5, logAll); // 0 1 2 3 4


// 익명 함수 리터럴을 콜백 함수로 고차 함수에 전달한다.
// 익명 함수 리터럴은 repeat 함수를 호출할 때마다 평가되어 함수 객체를 생성한다.
repeat(5, function (i) {
  if (i % 2) console.log(i);
}); // 1 3
```
- 비동기 처리에 활용됨(이벤트처리, ajax, 타이머 함수)
```javaScript
// 콜백 함수를 사용한 이벤트 처리
// myButton 버튼을 클릭하면 콜백 함수를 실행한다.
document.getElementById('myButton').addEventListener('click', function () {
  console.log('button clicked!');
});

// 콜백 함수를 사용한 비동기 처리
// 1초 후에 메시지를 출력한다.
setTimeout(function () {
  console.log('1초 경과');
}, 1000);
```
- 배열 고차 함수(map, filter, reduce 등)
```javaScript
var res = [1, 2, 3].map(function (item) {
  return item * 2;
});
```
### 순수 함수와 비순수 함수
- 순수 함수: 외부 상태에 의존하지 않고 변경하지도 않는 함수
- 비순수 함수: 외부 상태에 의존하거나 외부 상태를 변경하는 함수
> 함수형 프로그래밍의 목표
> - 비순수 함수 줄이기
> - 조건문과 반복문 제거하여 복잡성 해결
> - 변수 사용 억제, 생명주기 최소화

### 참고
- 리터럴: 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기 방식. 값을 생성하기 위한 표기법
